# 1주차 과제 보고서

---


## 1. 동시성 제어 기술 보고서

### 동시성이란

- 동시성은 여러 스레드가 동시에 공유 자원에 접근하거나 수정하려 할 때 발생하는 문제로, 임계 영역에서 멀티스레드 환경의 특성상 데이터 일관성과 안정성을 해치는 상황이 발생하는 것을 의미합니다.

### [주요 문제점]
- 데이터 일관성 문제
   - 여러 스레드가 동시에 데이터 수정
   - 예측 불가능한 결과 발생
   - 데이터 불일치 발생

- 데드락(Deadlock)
   - 스레드들이 서로의 자원을 기다림
   - 시스템 정지 가능성
   - 무한 대기 상태

- 성능 저하
   - 불필요한 스레드 대기
   - 리소스 낭비
   - 처리 속도 감소



## synchronized (Lock의 범위는 `객체 단위`)

#### 1. synchronized의 기본 개념과 동작 방식
   - synchronized는 Java에서 제공하는 가장 기본적인 동기화 방식입니다. 이는 `객체 단위로 락을 획득`하는 방식으로 동작하며, 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제를 해결합니다.
   
#### 2. 임계 영역과 모니터 락
- synchronized로 보호된 코드 블록은 임계 영역이 되며, 이 영역에 접근하기 위해서는 모니터 락을 획득해야 합니다. `모니터 락은 객체마다 하나씩 존재`하며, **synchronized 메서드나 블록에 진입할 때 자동으로 획득되고, 블록을 벗어날 때 자동으로 해제됩니다.**

#### 3. 스레드 상태 변화
- 스레드가 synchronized 블록에 진입하려고 할 때, `다른 스레드가 이미 락을 보유하고 있다면 해당 스레드는 Runnable 상태에서 Blocked 상태로 전환`됩니다. 이는 모니터 락이 없으면 스레드가 실행을 계속할 수 없다는 것을 의미합니다. 스레드는 락을 획득할 때까지 무한정 대기하게 되며, 이는 성능 저하의 원인이 될 수 있습니다.

#### 4. 비공정 락을 사용한다. (non-fair)
- synchronized는 Java에서 제공하는 가장 기본적인 동기화 메커니즘으로, 비공정(Non-fair) 락을 사용합니다. 이는 락이 해제될 때 대기 중인 스레드들 중에서 대기 시간과 관계없이 아무 스레드나 락을 획득할 수 있다는 것을 의미합니다. 
- synchronized의 `비공정 락은 락이 해제되는 즉시 대기 중인 스레드들 중 하나를 선택하여 락을 부여`합니다. 이때 스레드의 대기 시간이나 우선순위를 고려하지 않으며, JVM이 최적의 성능을 위해 스레드를 선택합니다.


#### 5. synchronized 장/단점
- 장점
  - 구현이 쉽다.
  - 성능 향상: 비공정 락은 스레드 스위칭을 최소화하여 컨텍스트 스위칭 오버헤드를 감소시키기 때문에 전반적인 성능이 좋다.
 

- **단점 (결국 Thread를 세밀하게 제어하지 못한다.)**
  - **기아 현상**: 비공정 락은 특정 스레드가 계속해서 락을 획득하지 못하는 상황을 일으킬 수 있습니다. 이는 우선순위가 낮은 스레드의 실행이 지연되거나, 특정 작업이 실행되지 않는 문제를 초래할 수 있습니다.
  
  - **무한 대기**: 락을 획득할 때까지 무한정 대기하게 되며, 이는 데드락이나 성능 저하를 일으킬 수 있습니다. 타임아웃 설정이나 조건부 대기와 같은 고급 기능을 제공하지 않습니다.


    
---

## synchronized 단점을 극복하기 위한 LockSupport 구현체 ReentrantLock

### 1. ReentrantLock의 기본 개념
   - ReentrantLock은 synchronized의 단점을 보완하기 위해 **도입된 Lock 인터페이스의 구현체**입니다. 이는 synchronized보다 더 유연하고 강력한 동기화 메커니즘을 제공합니다.

###  synchronized의 단점 해결
### 공정성(Fairness) 설정
- synchronized는 항상 비공정 락을 사용
- ReentrantLock은 공정/비공정 선택 가능
- 공정 락은 대기 시간이 긴 스레드 우선 처리


### 타임아웃 설정
- **parkNanos으로도 해결이 가능하다.**
- synchronized는 무한 대기
- ReentrantLock은 타임아웃 설정 가능
- 데드락 방지 가능

### 조건부 대기(Condition)
- synchronized는 단일 조건 대기만 가능
- ReentrantLock은 여러 조건에 대한 대기 가능
- 더 세밀한 스레드 제어 가능


### 성능 고려
- 공정 락은 성능 저하 가능성
- 상황에 맞는 락 전략 선택 필요
- 불필요한 락 사용 지양

## 4. 결론

- synchronized는 구현이 쉽고 성능이 비교적 좋은 성능의 장점이 있지만, 공정성과 기아 현상이라는 근본적인 문제가 있었습니다.
- 이러한 synchronized의 한계를 극복하기 위해 LockSupport 구현체인 ReentrantLock을 선택했습니다.
- ReentrantLock에서 기존에 문제를 park, parkNanos등 LockSupport를 사용하면 기존의 문제를 해결할 수 있다.
  - 기존에 synchronized에서 `Block`이 되었을 때 무한히 대기해야 될 수 있는데 LockSupport에서는 `Waiting`으로 특정 시간 타입아웃 또는 인터럽트로 빠져나올 수 있다. 즉. 세밀하게 Thread의 포인트를 컨트롤 할 수 있다.

- ReentrantLock은 공정성 설정, 타임아웃 처리, 조건부 대기 등 synchronized가 제공하지 못했던 기능들을 제공합니다. 
- ConcurrentHashMap과 함께 활용할 경우, 스레드 안전한 방식으로 사용자별 락을 효율적으로 관리할 수 있습니다. ConcurrentHashMap의 computeIfAbsent와 같은 원자적 연산은 멀티스레드 환경에서 안전하게 사용자별 락을 생성하고 관리할 수 있게 해주어, 더욱 세밀하고 효율적인 동시성 제어가 가능해집니다.